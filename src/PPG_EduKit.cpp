#include "PPG_EduKit.h"
#include <Wire.h>

#define     ADC_TIA     0U
#define     ADC_HPF     1U
#define     ADC_LPF     2U
#define     ADC_AMP     3U

const unsigned char PPG_EduKit_Logo [] PROGMEM = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x80, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x40, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x40, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x20, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x20, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x10, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x10, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x7f, 0xc0, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x01, 0xc0, 0x30, 0x01, 0xf8, 0x7f, 0x07, 0xe0, 0x3f, 0x00, 0x40, 0x06, 0x0c, 0x40, 0x00, 
  0x00, 0x02, 0x00, 0x08, 0x01, 0xfc, 0x7f, 0x0f, 0x70, 0x3f, 0x00, 0x40, 0x06, 0x1c, 0x40, 0x00, 
  0x00, 0x04, 0x00, 0x04, 0x01, 0x86, 0x61, 0x8c, 0x10, 0x20, 0x00, 0x40, 0x06, 0x18, 0x06, 0x00, 
  0x00, 0x04, 0x00, 0x04, 0x01, 0x86, 0x61, 0x98, 0x00, 0x20, 0x00, 0x40, 0x06, 0x30, 0x04, 0x00, 
  0x00, 0x08, 0x00, 0x02, 0x01, 0x86, 0x61, 0x98, 0x00, 0x20, 0x00, 0xc0, 0x06, 0x70, 0x06, 0x00, 
  0x00, 0x08, 0x10, 0x02, 0x01, 0x86, 0x61, 0x98, 0x00, 0x20, 0x0f, 0xcc, 0x26, 0x60, 0x4f, 0x00, 
  0x00, 0x08, 0x10, 0x02, 0x01, 0x8e, 0x63, 0x90, 0x00, 0x3e, 0x1f, 0xcc, 0x26, 0xc0, 0x4f, 0x00, 
  0x00, 0x08, 0x10, 0x82, 0x01, 0xfc, 0x7f, 0x10, 0x78, 0x3f, 0x10, 0xcc, 0x27, 0xc0, 0x46, 0x00, 
  0x00, 0x08, 0x30, 0x82, 0x01, 0xf0, 0x7c, 0x10, 0x7c, 0x30, 0x30, 0xcc, 0x26, 0xc0, 0x44, 0x00, 
  0x00, 0x0d, 0x30, 0x83, 0x01, 0x80, 0x60, 0x18, 0x08, 0x20, 0x30, 0x4c, 0x26, 0x60, 0x44, 0x00, 
  0x00, 0x61, 0xa8, 0xc0, 0xc1, 0x80, 0x60, 0x18, 0x08, 0x20, 0x30, 0x4c, 0x26, 0x30, 0x46, 0x00, 
  0x00, 0x7f, 0xc9, 0x4f, 0xa1, 0x80, 0x60, 0x0c, 0x18, 0x20, 0x30, 0xcc, 0x26, 0x38, 0x46, 0x00, 
  0x00, 0x7c, 0xc9, 0x5f, 0xe1, 0x80, 0x60, 0x0e, 0x38, 0x20, 0x18, 0xcc, 0x66, 0x18, 0x46, 0x00, 
  0x00, 0x60, 0xc9, 0x60, 0x41, 0x80, 0x60, 0x07, 0xf8, 0x3f, 0x1f, 0xc7, 0xe6, 0x0c, 0x47, 0x00, 
  0x00, 0x08, 0xc8, 0x23, 0x01, 0x80, 0x60, 0x03, 0xe0, 0x3f, 0x0f, 0xc7, 0xc2, 0x0e, 0x43, 0x00, 
  0x00, 0x08, 0x0a, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x08, 0x0a, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x08, 0x0e, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x08, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x08, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x02, 0x04, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x01, 0x80, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x71, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static uint8_t gNumberOfActiveChannels = 0U;
static uint8_t gAdc_channels[4] = {0U};


void PPG_EduKit::begin(PPG_EK_Peripherals *peripheralsList)
{
    uint8_t activeChannels = 0x00;

    Serial.begin(115200);

    Wire1.begin();


    pinMode(TLC5925_LE, OUTPUT);
    pinMode(TLC5925_OE, OUTPUT);
    pinMode(TLC5925_CLK, OUTPUT);
    pinMode(TLC5925_SDI, OUTPUT);

    digitalWrite(TLC5925_OE, HIGH);

#ifndef __SAM3X8E__
    pinMode(SWITCH_BUTTON, INPUT_PULLUP);
#endif

    if(peripheralsList->neoPixel == ENABLE_PERIPHERAL)
    {
        pixels.begin();
        delay(500);
        pixels.clear();
        pixels.show();
        delay(1000);
    }

#ifndef __SAM3X8E__
    if(peripheralsList->tempSensor == ENABLE_PERIPHERAL)
    {
        

        while(!tempSensor.scanAvailableSensors()){ delay(30000);}

        tempSensor.begin();
    }
#endif

    if(peripheralsList->oledDisplay == ENABLE_PERIPHERAL)
    {
        OLED_displaySetup();
    }
    
    if(peripheralsList->ppgSensor == ENABLE_PERIPHERAL)
    {
        if (!ppgSensor.begin(Wire1))
        {
            Serial.println("MAX30105 error!!!");
        }

        ppgSensor.setup(MAX30105_LED_BRIGHTNESS, MAX30105_SAMPLE_AVERAGE, MAX30105_LED_MODE, 
                          MAX30105_SAMPLE_RATE, MAX30105_PUSLE_WIDTH, MAX30105_ADC_RANGE); 
    }
    
    if(peripheralsList->read_TIA == ENABLE_PERIPHERAL)
    {
        activeChannels |= 1 << ADC_TIA;
    }
    if(peripheralsList->read_HPF == ENABLE_PERIPHERAL)
    {
        activeChannels |= 1 << ADC_HPF;
    }
    if(peripheralsList->read_LPF == ENABLE_PERIPHERAL)
    {
        activeChannels |= 1 << ADC_LPF;
    }
    if(peripheralsList->read_AMP == ENABLE_PERIPHERAL)
    {
        activeChannels |= 1 << ADC_AMP;
    }

    if(activeChannels != 0x00)
        ADC_Init(activeChannels);
}


void PPG_EduKit::OLED_displaySetup(void)
{
    display.begin(OLED_I2C_ADDRESS, true); 
    delay(1000);

    display.clearDisplay();
    display.setRotation(1);
    display.drawBitmap(0, 0, PPG_EduKit_Logo, 128, 64, 1); // display.drawBitmap(x position, y position, bitmap data, bitmap width, bitmap height, color)
    display.display();
    

    pinMode(OLED_BUTTON_A, INPUT_PULLUP);
    pinMode(OLED_BUTTON_B, INPUT_PULLUP);
    pinMode(OLED_BUTTON_C, INPUT_PULLUP);

}

void PPG_EduKit::enableLed(PPG_EK_Led ledType, uint16_t ledCurrent, boolean setCurrent)
{
    if(setCurrent == true)
    {
        AD5273_setLedCurrent(ledCurrent);    
    }

    switch(ledType)
    {
        case RED_LED:
            TLC5925_enableRed();
            break;
        case GREEN_LED:
            TLC5925_enableGreen(); 
            break;
        case IR_LED:
            TLC5925_enableIR(); 
            break;

        default:
            AD5273_setLedCurrent(0x00UL); 
            break;
    }

}

void PPG_EduKit::TLC5925_enableRed(void)
{
    /* LE must be low while data is being shifted in */
    digitalWrite(TLC5925_LE, LOW);
    /* Data shifted with CLK rising edge. This makes sure the CLK starts in LOW position */ 
    digitalWrite(TLC5925_CLK, LOW);
    /* OE high keep leds turned off while data is shifted in */
    digitalWrite(TLC5925_OE, HIGH); 
    
    /* Shift out the data to turn green led on: 0000 0000 0000 0010. shiftOut() shifts 1 byte at a time, so the function is called twice. */
    /* First byte corresponding to outputs 15 to 8. ALL UNUSED */
    shiftOut(TLC5925_SDI, TLC5925_CLK, MSBFIRST, 0x00); 
    /* Second byte corresponding to outputs 7 to 0. 7 to 5 unused. */
    shiftOut(TLC5925_SDI, TLC5925_CLK, MSBFIRST, 0b00000001); 
    
    /* LE toggled to latch in the shifted data */
    digitalWrite(TLC5925_LE, HIGH);
    digitalWrite(TLC5925_LE, LOW);
    /* Enable output drive */
    digitalWrite(TLC5925_OE, LOW);
}


void PPG_EduKit::TLC5925_enableGreen(void)
{
    /* LE must be low while data is being shifted in */
    digitalWrite(TLC5925_LE, LOW);
    /* Data shifted with CLK rising edge. This makes sure the CLK starts in LOW position */ 
    digitalWrite(TLC5925_CLK, LOW);
    /* OE high keep leds turned off while data is shifted in */
    digitalWrite(TLC5925_OE, HIGH); 
    
    /* Shift out the data to turn green led on: 0000 0000 0000 0010. shiftOut() shifts 1 byte at a time, so the function is called twice. */
    /* First byte corresponding to outputs 15 to 8. ALL UNUSED */
    shiftOut(TLC5925_SDI, TLC5925_CLK, MSBFIRST, 0x00); 
    /* Second byte corresponding to outputs 7 to 0. 7 to 5 unused. */
    shiftOut(TLC5925_SDI, TLC5925_CLK, MSBFIRST, 0b00000010); 
    
    /* LE toggled to latch in the shifted data */
    digitalWrite(TLC5925_LE, HIGH);
    digitalWrite(TLC5925_LE, LOW);
    /* Enable output drive */
    digitalWrite(TLC5925_OE, LOW);
}

void PPG_EduKit::TLC5925_enableIR(void)
{
    /* LE must be low while data is being shifted in */
    digitalWrite(TLC5925_LE, LOW);
    /* Data shifted with CLK rising edge. This makes sure the CLK starts in LOW position */ 
    digitalWrite(TLC5925_CLK, LOW);
    /* OE high keep leds turned off while data is shifted in */
    digitalWrite(TLC5925_OE, HIGH); 
    
    /* Shift out the data to turn green led on: 0000 0000 0000 0010. shiftOut() shifts 1 byte at a time, so the function is called twice. */
    /* First byte corresponding to outputs 15 to 8. ALL UNUSED */
    shiftOut(TLC5925_SDI, TLC5925_CLK, MSBFIRST, 0x00); 
    /* Second byte corresponding to outputs 7 to 0. 7 to 5 unused. */
    shiftOut(TLC5925_SDI, TLC5925_CLK, MSBFIRST, 0b00001100); 
    
    /* LE toggled to latch in the shifted data */
    digitalWrite(TLC5925_LE, HIGH);
    digitalWrite(TLC5925_LE, LOW);
    /* Enable output drive */
    digitalWrite(TLC5925_OE, LOW);

}

void PPG_EduKit::AD5273_setLedCurrent(uint16_t val)
{
    uint8_t returned_bytes = 0U;
    uint16_t resVal = 0UL;
    uint8_t rdacVal = 0U;

    /* Current to resistance conversion. See 9.2.2.1 chapter in tlc5925.pdf datasheet */
    resVal = (uint16_t)(1000 * ((float)(1.21 * 18)/val));

    if(0x00UL != resVal)
    {
      /* R_WB(D) = (D * R_AB)/63 + R_W 
        rdacVal is D in this equation*/
      rdacVal = (uint8_t)ceil(((resVal - AD5273_R_W_VALUE)/ (float)AD5273_R_AB_VALUE) * 63.0);
    }

    /* Start communicating to the AD5273 at the specific address */
    Wire1.beginTransmission((uint8_t) AD5273_I2C_ADDRESS);
    /* Send the first byte 0h, to indicate the non-OTP operation */
    Wire1.write(0x00);
    /* Send the D value from 0 to  63 for the digipot resisitance */
    Wire1.write(rdacVal);
    /* Complete Transmission */
    Wire1.endTransmission();

    /* Read Written Value from the device (Read from AD5273) */
    /* Request 2 bytes from the AD5273 */
    returned_bytes = Wire1.requestFrom(AD5273_I2C_ADDRESS, 1);
    /* If no data was returned, something was wrong during the connection */
    if(returned_bytes == 0x00)
    {
        while(1); //halt the program
    }

    /* Read the digipot and store into a variable. It's two's complement (16bits signed) data */
    int readValue =  Wire1.read();
    if(rdacVal != readValue)
    {
        while(1); //halt the program
    }
}

void PPG_EduKit::ADC_Init(uint8_t channels)
{
    uint8_t count = 0;
    
    if(channels & (1 << ADC_TIA))
    {
        count++;
        gAdc_Channels[ADC_TIA] = 0x00;
    }

    if(channels & (1 << ADC_HPF))
    {
        count++;
        gAdc_Channels[ADC_HPF] = 0x01;
    }

    if(channels & (1 << ADC_LPF))
    {
        count++;
        gAdc_Channels[ADC_LPF] = 0x02;
    }

    if(channels & (1 << ADC_AMP))
    {
        count++;
        gAdc_Channels[ADC_AMP] = 0x03;
    }

    gNumberOfActiveChannels = count;
    PMC->PMC_PCER1 |= PMC_PCER1_PID37;      // ADC power on
    ADC->ADC_CR = ADC_CR_SWRST;             // Reset ADC
    ADC->ADC_MR |= ADC_MR_TRGEN_EN |        // Hardware trigger select
                   ADC_MR_PRESCAL(200) |    // the pre-scaler: as high as possible for better accuracy, while still fast enough to measure everything
                                            // see: https://arduino.stackexchange.com/questions/12723/how-to-slow-adc-clock-speed-to-1mhz-on-arduino-due
                                            // unclear, asked: https://stackoverflow.com/questions/64243073/setting-right-adc-prescaler-on-the-arduino-due-in-timer-and-interrupt-driven-mul
                   ADC_MR_TRGSEL_ADC_TRIG3; // Trigger by TIOA2 Rising edge

    ADC->ADC_IDR = ~(0ul);
    ADC->ADC_CHDR = ~(0ul);
    for (int i = 0; i < gNumberOfActiveChannels; i++)
    {
      ADC->ADC_CHER |= ADC_CHER_CH0 << gAdc_Channels[i];
    }
    ADC->ADC_IER |= ADC_IER_EOC0 << gAdc_Channels[gNumberOfActiveChannels - 1];
    ADC->ADC_PTCR |= ADC_PTCR_RXTDIS | ADC_PTCR_TXTDIS; // Disable PDC DMA
    NVIC_EnableIRQ(ADC_IRQn); 


    PMC->PMC_PCER0 |= PMC_PCER0_PID29;                     // TC2 power ON : Timer Counter 0 channel 2 IS TC2
    TC0->TC_CHANNEL[2].TC_CMR = TC_CMR_TCCLKS_TIMER_CLOCK2 // clock 2 has frequency MCK/8, clk on rising edge
                              | TC_CMR_WAVE              // Waveform mode
                              | TC_CMR_WAVSEL_UP_RC      // UP mode with automatic trigger on RC Compare
                              | TC_CMR_ACPA_CLEAR        // Clear TIOA2 on RA compare match
                              | TC_CMR_ACPC_SET;         // Set TIOA2 on RC compare match

    constexpr int ticks_per_sample = F_CPU / 8 / ADC_SAMPLE_RATE; // F_CPU / 8 is the timer clock frequency, see MCK/8 setup
    constexpr int ticks_duty_cycle = ticks_per_sample / 2;        // duty rate up vs down ticks over timer cycle; use 50%
    TC0->TC_CHANNEL[2].TC_RC = ticks_per_sample;
    TC0->TC_CHANNEL[2].TC_RA = ticks_duty_cycle;

    TC0->TC_CHANNEL[2].TC_CCR = TC_CCR_SWTRG | TC_CCR_CLKEN; // Software trigger TC2 counter and enable

}


void ADC_Handler()
{
    /*
  for (uint8_t i = 0; i < gNumberOfActiveChannels; i++)
  {
    adc_meas_buffer[crrt_adc_meas_buffer_idx][i] = static_cast<volatile uint16_t>(*(ADC->ADC_CDR + gAdc_Channels[i]) & 0x0FFFF);
  }

  crrt_adc_meas_buffer_idx = (crrt_adc_meas_buffer_idx + 1) % adc_buffer_nbr_consec_meas;

  adc_flag_conversion = true;
  */
}