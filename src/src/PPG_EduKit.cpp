#include "PPG_EduKit.h"
#include <Wire.h>

#define     ADC_TIA     0U
#define     ADC_HPF     1U
#define     ADC_LPF     2U
#define     ADC_AMP     3U

#define     ADC_TIA_PIN     A0
#define     ADC_HPF_PIN     A1
#define     ADC_LPF_PIN     A2
#define     ADC_AMP_PIN     A3


#define ADC_MR_TRIG1 (1 << 1)

const unsigned char PPG_EduKit_Logo [] PROGMEM = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x80, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x40, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x40, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x20, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x20, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x10, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x10, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x7f, 0xc0, 0x00, 0x00, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x01, 0xc0, 0x30, 0x01, 0xf8, 0x7f, 0x07, 0xe0, 0x3f, 0x00, 0x40, 0x06, 0x0c, 0x40, 0x00, 
  0x00, 0x02, 0x00, 0x08, 0x01, 0xfc, 0x7f, 0x0f, 0x70, 0x3f, 0x00, 0x40, 0x06, 0x1c, 0x40, 0x00, 
  0x00, 0x04, 0x00, 0x04, 0x01, 0x86, 0x61, 0x8c, 0x10, 0x20, 0x00, 0x40, 0x06, 0x18, 0x06, 0x00, 
  0x00, 0x04, 0x00, 0x04, 0x01, 0x86, 0x61, 0x98, 0x00, 0x20, 0x00, 0x40, 0x06, 0x30, 0x04, 0x00, 
  0x00, 0x08, 0x00, 0x02, 0x01, 0x86, 0x61, 0x98, 0x00, 0x20, 0x00, 0xc0, 0x06, 0x70, 0x06, 0x00, 
  0x00, 0x08, 0x10, 0x02, 0x01, 0x86, 0x61, 0x98, 0x00, 0x20, 0x0f, 0xcc, 0x26, 0x60, 0x4f, 0x00, 
  0x00, 0x08, 0x10, 0x02, 0x01, 0x8e, 0x63, 0x90, 0x00, 0x3e, 0x1f, 0xcc, 0x26, 0xc0, 0x4f, 0x00, 
  0x00, 0x08, 0x10, 0x82, 0x01, 0xfc, 0x7f, 0x10, 0x78, 0x3f, 0x10, 0xcc, 0x27, 0xc0, 0x46, 0x00, 
  0x00, 0x08, 0x30, 0x82, 0x01, 0xf0, 0x7c, 0x10, 0x7c, 0x30, 0x30, 0xcc, 0x26, 0xc0, 0x44, 0x00, 
  0x00, 0x0d, 0x30, 0x83, 0x01, 0x80, 0x60, 0x18, 0x08, 0x20, 0x30, 0x4c, 0x26, 0x60, 0x44, 0x00, 
  0x00, 0x61, 0xa8, 0xc0, 0xc1, 0x80, 0x60, 0x18, 0x08, 0x20, 0x30, 0x4c, 0x26, 0x30, 0x46, 0x00, 
  0x00, 0x7f, 0xc9, 0x4f, 0xa1, 0x80, 0x60, 0x0c, 0x18, 0x20, 0x30, 0xcc, 0x26, 0x38, 0x46, 0x00, 
  0x00, 0x7c, 0xc9, 0x5f, 0xe1, 0x80, 0x60, 0x0e, 0x38, 0x20, 0x18, 0xcc, 0x66, 0x18, 0x46, 0x00, 
  0x00, 0x60, 0xc9, 0x60, 0x41, 0x80, 0x60, 0x07, 0xf8, 0x3f, 0x1f, 0xc7, 0xe6, 0x0c, 0x47, 0x00, 
  0x00, 0x08, 0xc8, 0x23, 0x01, 0x80, 0x60, 0x03, 0xe0, 0x3f, 0x0f, 0xc7, 0xc2, 0x0e, 0x43, 0x00, 
  0x00, 0x08, 0x0a, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x08, 0x0a, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x08, 0x0e, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x08, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x08, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x02, 0x04, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x01, 0x80, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x71, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};


volatile uint16_t  PPG_EduKit::PPG_EduKit_TIA_Buffer[MAX_BUFFER_SIZE] = {0UL};
volatile uint16_t  PPG_EduKit::PPG_EduKit_HPF_Buffer[MAX_BUFFER_SIZE] = {0UL};
volatile uint16_t  PPG_EduKit::PPG_EduKit_LPF_Buffer[MAX_BUFFER_SIZE] = {0UL};
volatile uint16_t  PPG_EduKit::PPG_EduKit_AMP_Buffer[MAX_BUFFER_SIZE] = {0UL};
volatile uint16_t  PPG_EduKit::PPG_EduKIT_BufferHead = 0UL;
volatile boolean   PPG_EduKit::bufferProcessed = true; 

uint8_t PPG_EduKit::numberOfActiveChannels = 0U;
uint8_t PPG_EduKit::adcChannels[4] = {0};
uint8_t PPG_EduKit::activeChannels = 0U;


//void ADC_Handler(void)
//{
//	  digitalWrite(24, !digitalRead(24));
//}

void PPG_EduKit::begin(PPG_EK_Peripherals *peripheralsList)
{
    Serial.begin(115200);

    Wire1.begin();

    pinMode(TLC5925_LE, OUTPUT);
    pinMode(TLC5925_OE, OUTPUT);
    pinMode(TLC5925_CLK, OUTPUT);
    pinMode(TLC5925_SDI, OUTPUT);

    digitalWrite(TLC5925_OE, HIGH);

#ifndef __SAM3X8E__
    pinMode(SWITCH_BUTTON, INPUT_PULLUP);
#endif

    if(peripheralsList->neoPixel == ENABLE_PERIPHERAL)
    {
        pixels.begin();
        delay(500);
        pixels.clear();
        pixels.show();
        delay(1000);
    }

#ifndef __SAM3X8E__
    if(peripheralsList->tempSensor == ENABLE_PERIPHERAL)
    {
        

        while(!tempSensor.scanAvailableSensors()){ delay(30000);}

        tempSensor.begin();
    }
#endif

    if(peripheralsList->oledDisplay == ENABLE_PERIPHERAL)
    {
        OLED_displaySetup();
    }
    
    if(peripheralsList->ppgSensor == ENABLE_PERIPHERAL)
    {
        if (!ppgSensor.begin(Wire1))
        {
            Serial.println("MAX30105 error!!!");
        }

        ppgSensor.setup(MAX30105_LED_BRIGHTNESS, MAX30105_SAMPLE_AVERAGE, MAX30105_LED_MODE, 
                          MAX30105_SAMPLE_RATE, MAX30105_PUSLE_WIDTH, MAX30105_ADC_RANGE); 
    }
    
    if(peripheralsList->read_TIA == ENABLE_PERIPHERAL)
    {
        activeChannels |= 1 << ADC_TIA;
    }
    if(peripheralsList->read_HPF == ENABLE_PERIPHERAL)
    {
        activeChannels |= 1 << ADC_HPF;
    }
    if(peripheralsList->read_LPF == ENABLE_PERIPHERAL)
    {
        activeChannels |= 1 << ADC_LPF;
    }
    if(peripheralsList->read_AMP == ENABLE_PERIPHERAL)
    {
        activeChannels |= 1 << ADC_AMP;
    }


    if(activeChannels != 0x00U)
    {
       //TIMER_Init(TIMER_TICK_PERIOD);
       //ADC_Init(activeChannels);
    } 
    
}


void PPG_EduKit::OLED_displaySetup(void)
{
    display.begin(OLED_I2C_ADDRESS, true); 
    delay(1000);

    display.clearDisplay();
    display.setRotation(1);
    display.drawBitmap(0, 0, PPG_EduKit_Logo, 128, 64, 1); // display.drawBitmap(x position, y position, bitmap data, bitmap width, bitmap height, color)
    display.display();
    

    pinMode(OLED_BUTTON_A, INPUT_PULLUP);
    pinMode(OLED_BUTTON_B, INPUT_PULLUP);
    pinMode(OLED_BUTTON_C, INPUT_PULLUP);

}

void PPG_EduKit::enableLed(PPG_EK_Led ledType, uint16_t ledCurrent, boolean setCurrent)
{
    if(setCurrent == true)
    {
        AD5273_setLedCurrent(ledCurrent);    
    }

    switch(ledType)
    {
        case RED_LED:
            TLC5925_enableRed();
            break;
        case GREEN_LED:
            TLC5925_enableGreen(); 
            break;
        case IR_LED:
            TLC5925_enableIR(); 
            break;

        default:
            AD5273_setLedCurrent(0x00UL); 
            break;
    }

}

void PPG_EduKit::TLC5925_enableRed(void)
{
    /* LE must be low while data is being shifted in */
    digitalWrite(TLC5925_LE, LOW);
    /* Data shifted with CLK rising edge. This makes sure the CLK starts in LOW position */ 
    digitalWrite(TLC5925_CLK, LOW);
    /* OE high keep leds turned off while data is shifted in */
    digitalWrite(TLC5925_OE, HIGH); 
    
    /* Shift out the data to turn green led on: 0000 0000 0000 0010. shiftOut() shifts 1 byte at a time, so the function is called twice. */
    /* First byte corresponding to outputs 15 to 8. ALL UNUSED */
    shiftOut(TLC5925_SDI, TLC5925_CLK, MSBFIRST, 0x00); 
    /* Second byte corresponding to outputs 7 to 0. 7 to 5 unused. */
    shiftOut(TLC5925_SDI, TLC5925_CLK, MSBFIRST, 0b00000001); 
    
    /* LE toggled to latch in the shifted data */
    digitalWrite(TLC5925_LE, HIGH);
    digitalWrite(TLC5925_LE, LOW);
    /* Enable output drive */
    digitalWrite(TLC5925_OE, LOW);
}


void PPG_EduKit::TLC5925_enableGreen(void)
{
    /* LE must be low while data is being shifted in */
    digitalWrite(TLC5925_LE, LOW);
    /* Data shifted with CLK rising edge. This makes sure the CLK starts in LOW position */ 
    digitalWrite(TLC5925_CLK, LOW);
    /* OE high keep leds turned off while data is shifted in */
    digitalWrite(TLC5925_OE, HIGH); 
    
    /* Shift out the data to turn green led on: 0000 0000 0000 0010. shiftOut() shifts 1 byte at a time, so the function is called twice. */
    /* First byte corresponding to outputs 15 to 8. ALL UNUSED */
    shiftOut(TLC5925_SDI, TLC5925_CLK, MSBFIRST, 0x00); 
    /* Second byte corresponding to outputs 7 to 0. 7 to 5 unused. */
    shiftOut(TLC5925_SDI, TLC5925_CLK, MSBFIRST, 0b00000010); 
    
    /* LE toggled to latch in the shifted data */
    digitalWrite(TLC5925_LE, HIGH);
    digitalWrite(TLC5925_LE, LOW);
    /* Enable output drive */
    digitalWrite(TLC5925_OE, LOW);
}

void PPG_EduKit::TLC5925_enableIR(void)
{
    /* LE must be low while data is being shifted in */
    digitalWrite(TLC5925_LE, LOW);
    /* Data shifted with CLK rising edge. This makes sure the CLK starts in LOW position */ 
    digitalWrite(TLC5925_CLK, LOW);
    /* OE high keep leds turned off while data is shifted in */
    digitalWrite(TLC5925_OE, HIGH); 
    
    /* Shift out the data to turn green led on: 0000 0000 0000 0010. shiftOut() shifts 1 byte at a time, so the function is called twice. */
    /* First byte corresponding to outputs 15 to 8. ALL UNUSED */
    shiftOut(TLC5925_SDI, TLC5925_CLK, MSBFIRST, 0x00); 
    /* Second byte corresponding to outputs 7 to 0. 7 to 5 unused. */
    shiftOut(TLC5925_SDI, TLC5925_CLK, MSBFIRST, 0b00001100); 
    
    /* LE toggled to latch in the shifted data */
    digitalWrite(TLC5925_LE, HIGH);
    digitalWrite(TLC5925_LE, LOW);
    /* Enable output drive */
    digitalWrite(TLC5925_OE, LOW);

}

void PPG_EduKit::AD5273_setLedCurrent(uint16_t val)
{
    uint8_t returned_bytes = 0U;
    uint16_t resVal = 0UL;
    uint8_t rdacVal = 0U;

    /* Current to resistance conversion. See 9.2.2.1 chapter in tlc5925.pdf datasheet */
    resVal = (uint16_t)(1000 * ((float)(1.21 * 18)/val));

    if(0x00UL != resVal)
    {
      /* R_WB(D) = (D * R_AB)/63 + R_W 
        rdacVal is D in this equation*/
      rdacVal = (uint8_t)ceil(((resVal - AD5273_R_W_VALUE)/ (float)AD5273_R_AB_VALUE) * 63.0);
    }

    /* Start communicating to the AD5273 at the specific address */
    Wire1.beginTransmission((uint8_t) AD5273_I2C_ADDRESS);
    /* Send the first byte 0h, to indicate the non-OTP operation */
    Wire1.write(0x00);
    /* Send the D value from 0 to  63 for the digipot resisitance */
    Wire1.write(rdacVal);
    /* Complete Transmission */
    Wire1.endTransmission();

    /* Read Written Value from the device (Read from AD5273) */
    /* Request 2 bytes from the AD5273 */
    returned_bytes = Wire1.requestFrom(AD5273_I2C_ADDRESS, 1);
    /* If no data was returned, something was wrong during the connection */
    if(returned_bytes == 0x00)
    {
        while(1); //halt the program
    }

    /* Read the digipot and store into a variable. It's two's complement (16bits signed) data */
    int readValue =  Wire1.read();
    if(rdacVal != readValue)
    {
        while(1); //halt the program
    }
}
/*
void PPG_EduKit::readChannels()
{
    while (ADC_Sampler.available() && (MAX_BUFFER_SIZE != PPG_EduKIT_BufferHead)) 
    {
        uint16_t *ch_samples = ADC_Sampler.get();
        if(activeChannels & (1 << ADC_TIA))
        {
            PPG_EduKit_TIA_Buffer[PPG_EduKIT_BufferHead] = ch_samples[ADC_TIA];
        }
    
        if(activeChannels & (1 << ADC_HPF))
        {
            PPG_EduKit_HPF_Buffer[PPG_EduKIT_BufferHead] = ch_samples[ADC_HPF];
        }
    
        if(activeChannels & (1 << ADC_LPF))
        {
            PPG_EduKit_LPF_Buffer[PPG_EduKIT_BufferHead] = ch_samples[ADC_LPF];
        }
    
        if(activeChannels & (1 << ADC_AMP))
        {
            PPG_EduKit_AMP_Buffer[PPG_EduKIT_BufferHead] = ch_samples[ADC_AMP];
        }
        PPG_EduKIT_BufferHead++;
        bufferProcessed = true;
    }

    PPG_EduKIT_BufferHead = 0;
}
*/

void PPG_EduKit::ADC_Init(uint8_t channels)
{
    uint8_t count = 0;
    if(channels & (1 << ADC_TIA))
    {
        adcChannels[count] = 0x00;
        count++;
    }

    if(channels & (1 << ADC_HPF))
    {
        adcChannels[count] = 0x01;
        count++;
    }

    if(channels & (1 << ADC_LPF))
    {
        adcChannels[count] = 0x02;
        count++;
    }

    if(channels & (1 << ADC_AMP))
    {
        adcChannels[count] = 0x03;
        count++;
    }
   
    numberOfActiveChannels = count;
 
    PMC->PMC_PCER1 |= PMC_PCER1_PID37;                    // ADC power on
    ADC->ADC_CR = ADC_CR_SWRST;                           // Reset ADC
    ADC->ADC_MR |=  ADC_MR_TRGEN_EN                       // Hardware trigger select
                    | ADC_MR_TRGSEL_ADC_TRIG3             // Trigger by TIOA2
                    | ADC_MR_PRESCAL(1);
    ADC->ADC_ACR = ADC_ACR_IBCTL(0b01);                   // For frequencies > 500 KHz

    ADC->ADC_CHER = ADC_CHER_CH7;                        // Enable ADC CH7 = A0
    ADC->ADC_IER = ADC_IER_EOC7;                         // Interrupt on End of conversion
    NVIC_EnableIRQ(ADC_IRQn);                            // Enable ADC interrupt
}


void PPG_EduKit::TIMER_Init(uint32_t ticks) 
{

  PMC->PMC_PCER0 |= PMC_PCER0_PID29;                      // TC2 power ON : Timer Counter 0 channel 2 IS TC2
  TC0->TC_CHANNEL[2].TC_CMR = TC_CMR_TCCLKS_TIMER_CLOCK2  // MCK/8, clk on rising edge
                              | TC_CMR_WAVE               // Waveform mode
                              | TC_CMR_WAVSEL_UP_RC        // UP mode with automatic trigger on RC Compare
                              | TC_CMR_ACPA_CLEAR          // Clear TIOA2 on RA compare match
                              | TC_CMR_ACPC_SET;           // Set TIOA2 on RC compare match


   TC0->TC_CHANNEL[2].TC_RC = 238;  //<*********************  Frequency = (Mck/8)/TC_RC  Hz = 44.117 Hz
   TC0->TC_CHANNEL[2].TC_RA = 40;  //<********************   Any Duty cycle in between 1 and 874

   TC0->TC_CHANNEL[2].TC_CCR = TC_CCR_SWTRG | TC_CCR_CLKEN; // Software tr

}


void PPG_EduKit::ADC_HandlerISR()
{
  
}


